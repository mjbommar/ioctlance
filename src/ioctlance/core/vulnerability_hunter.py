"""Vulnerability hunting module for IOCTLance."""

import logging
import time
from pathlib import Path
from typing import Any, cast

import angr
import claripy
from angr import SimState, SimulationManager
from claripy.ast.bv import BV

from ..core.analysis_context import AnalysisContext
from ..models import IOCTLHandler, Vulnerability
from ..symbolic import breakpoints
from ..symbolic.techniques import ExplosionDetector

logger = logging.getLogger(__name__)


class VulnerabilityHunter:
    """Hunts for vulnerabilities in Windows drivers using symbolic execution."""

    def __init__(self, context: AnalysisContext) -> None:
        """Initialize the vulnerability hunter.

        Args:
            context: Analysis context with driver and configuration
        """
        self.context = context
        self.context.phase = 2  # Phase 2 = hunting vulnerabilities

    def hunt(
        self, driver_base_state: SimState, ioctl_handler_addr: int, ioctl_code: str | None = None
    ) -> list[dict[str, Any]]:
        """Hunt for vulnerabilities in the IOCTL handler.

        Args:
            driver_base_state: Base state from IOCTL handler discovery
            ioctl_handler_addr: Address of the IOCTL handler
            ioctl_code: Specific IOCTL code to test (hex string)

        Returns:
            List of discovered vulnerabilities
        """
        # If hunting for specific IOCTL, use targeted approach
        if ioctl_code:
            return self._hunt_specific_ioctl(driver_base_state, ioctl_handler_addr, ioctl_code)

        # Otherwise do general hunting to discover all IOCTLs
        # Set up device object address
        # Cast globals to dict-like for type checker
        globals_dict = cast(dict[str, Any], driver_base_state.globals)
        if "device_object_addr" in globals_dict:
            device_object_addr = claripy.BVV(globals_dict["device_object_addr"], driver_base_state.arch.bits)
        else:
            device_object_addr = claripy.BVS("device_object_addr", driver_base_state.arch.bits)
            globals_dict["open_section_handles"] = ()
            globals_dict["tainted_unicode_strings"] = ()

            # Symbolize global variables if configured
            if self.context.config.global_var_size:
                self._symbolize_data_section(driver_base_state)

        # Initialize tainted tracking
        globals_dict["tainted_ProbeForRead"] = ()
        globals_dict["tainted_ProbeForWrite"] = ()
        globals_dict["tainted_MmIsAddressValid"] = ()
        globals_dict["tainted_eprocess"] = ()
        globals_dict["tainted_handles"] = ()

        # Create state at IOCTL handler entry point with resilience options
        # to handle unsupported VEX operations like Iop_32Uto64
        import angr

        state = self.context.project.factory.call_state(
            ioctl_handler_addr,
            device_object_addr,
            self.context.irp_addr,
            cc=self.context.calling_convention,
            base_state=driver_base_state,
            add_options=angr.options.resilience,
        )

        # Store context in state globals so hooks can access it
        cast(dict[str, Any], state.globals)["analysis_context"] = self.context

        # Set up CR8 register (interrupt priority level)
        cr8 = claripy.BVS("cr8", state.arch.bits)
        state.registers.store("cr8", cr8)

        # Set up IRP structure
        irp = claripy.BVS("irp_buf", 8 * 0x200)
        self.context.system_buffer = claripy.BVS("SystemBuffer", state.arch.bits)
        self.context.type3_input_buffer = claripy.BVS("Type3InputBuffer", state.arch.bits)
        self.context.user_buffer = claripy.BVS("UserBuffer", state.arch.bits)

        # Clear existing breakpoints and set up vulnerability detection breakpoints
        self._setup_breakpoints(state)

        # Store IRP in memory
        state.memory.store(self.context.irp_addr, irp)

        # Set up symbolic IOCTL parameters
        claripy.BVS("MajorFunction", 8)
        minor_func = claripy.BVS("MinorFunction", 8)
        self.context.output_buffer_length = claripy.BVS("OutputBufferLength", 32)
        self.context.input_buffer_length = claripy.BVS("InputBufferLength", 32)
        self.context.io_control_code = claripy.BVS("IoControlCode", 32)

        # Set up IRP structure fields
        self._setup_irp_structure(state, minor_func)

        # Set specific IOCTL code if provided
        if ioctl_code:
            self._set_ioctl_code(state, ioctl_code)

        # Create simulation manager with unconstrained state tracking
        simgr = self.context.project.factory.simgr(state, save_unconstrained=True)
        simgr.populate("found", [])
        simgr.use_technique(angr.exploration_techniques.DFS())

        # Set up exploration techniques
        self._setup_exploration_techniques(simgr)

        # Store simulation manager in context for breakpoints
        self.context.simulation_manager = simgr

        # Run symbolic execution
        self._run_symbolic_execution(simgr)

        return self.context.vulnerabilities

    def _symbolize_data_section(self, state: SimState) -> None:
        """Symbolize the .data section if configured.

        Args:
            state: State to modify
        """
        for segment in self.context.project.loader.main_object.segments:
            if ".data" in segment.name:
                size = min(segment.memsize, self.context.config.global_var_size)
                data = claripy.BVS(".data", 8 * size).reversed
                state.memory.store(segment.vaddr, data, size)
                break

    def _setup_breakpoints(self, state: SimState) -> None:
        """Set up breakpoints for vulnerability detection.

        Args:
            state: State to add breakpoints to
        """
        # Clear existing breakpoints
        for bp_type in ["mem_write", "call", "expr"]:
            while state.inspect._breakpoints.get(bp_type):
                state.inspect._breakpoints[bp_type].pop()

        # Set up vulnerability detection breakpoints
        # These use lambda wrappers to pass context
        state.inspect.b(
            "mem_read",
            when=angr.BP_BEFORE,
            action=lambda s: breakpoints.b_mem_read(s, self.context),
        )
        state.inspect.b(
            "mem_write",
            when=angr.BP_BEFORE,
            action=lambda s: breakpoints.b_mem_write(s, self.context),
        )
        state.inspect.b("call", when=angr.BP_BEFORE, action=lambda s: breakpoints.b_call(s, self.context))
        state.inspect.b("expr", when=angr.BP_BEFORE, action=lambda s: breakpoints.b_vex_expr(s, self.context))

    def _setup_irp_structure(self, state: SimState, minor_func: BV) -> None:
        """Set up the IRP and IO_STACK_LOCATION structures.

        Args:
            state: State to modify
            minor_func: Minor function symbolic variable
        """
        # Set IRP fields
        state.mem[self.context.irp_addr].IRP.Tail.Overlay.s.u.CurrentStackLocation = self.context.irsp_addr
        state.mem[self.context.irp_addr].IRP.AssociatedIrp.SystemBuffer = self.context.system_buffer
        state.mem[self.context.irp_addr].IRP.UserBuffer = self.context.user_buffer
        state.mem[self.context.irp_addr].IRP.RequestorMode = 1  # UserMode

        # Set IO_STACK_LOCATION fields
        # IRP_MJ_DEVICE_CONTROL = 14
        state.mem[self.context.irsp_addr].IO_STACK_LOCATION.MajorFunction = 14
        state.mem[self.context.irsp_addr].IO_STACK_LOCATION.MinorFunction = minor_func

        # Set DeviceIoControl parameters
        params = state.mem[self.context.irsp_addr].IO_STACK_LOCATION.Parameters
        params.DeviceIoControl.OutputBufferLength.val = self.context.output_buffer_length
        params.DeviceIoControl.InputBufferLength.val = self.context.input_buffer_length
        params.DeviceIoControl.Type3InputBuffer = self.context.type3_input_buffer
        params.DeviceIoControl.IoControlCode.val = self.context.io_control_code

    def _set_ioctl_code(self, state: SimState, ioctl_code: str) -> None:
        """Set a specific IOCTL code for testing.

        Args:
            state: State to modify
            ioctl_code: IOCTL code in hex format (e.g., "0x22201c")
        """
        ioctl_val = int(ioctl_code, 16)
        params = state.mem[self.context.irsp_addr].IO_STACK_LOCATION.Parameters
        params.DeviceIoControl.IoControlCode.val = ioctl_val
        state.add_constraints(self.context.io_control_code == ioctl_val)

        self.context.print_info(f"Testing specific IoControlCode: {ioctl_code}")

    def _setup_exploration_techniques(self, simgr: SimulationManager) -> None:
        """Set up exploration techniques for the simulation manager.

        Args:
            simgr: Simulation manager to configure
        """
        # Set loop bounds if configured
        if self.context.config.bound:
            simgr.use_technique(
                angr.exploration_techniques.LoopSeer(
                    cfg=self.context.cfg, functions=None, bound=self.context.config.bound
                )
            )
            simgr.use_technique(angr.exploration_techniques.LocalLoopSeer(bound=self.context.config.bound))

        # Set instruction length limit if configured
        if self.context.config.length:
            simgr.use_technique(angr.exploration_techniques.LengthLimiter(self.context.config.length))

        # Set up state explosion detection
        ed = ExplosionDetector(self.context, threshold=10000)
        simgr.use_technique(ed)
        self._explosion_detector = ed

    def _run_symbolic_execution(self, simgr: SimulationManager) -> None:
        """Run symbolic execution to hunt for vulnerabilities.

        Args:
            simgr: Simulation manager to execute
        """
        start_time = time.time()
        step_count = 0
        max_steps = 500000  # Match old tool's exhaustive exploration
        # Use the larger of ioctl_timeout or main timeout, especially for complete mode
        timeout = max(
            self.context.config.ioctl_timeout or 60,
            self.context.config.timeout if self.context.config.complete_mode else 60,
        )
        max_states = 500  # Much higher to avoid pruning valid paths

        while (
            (len(simgr.active) > 0 or len(simgr.deferred) > 0)
            and not self._explosion_detector.state_exploded_bool
            and step_count < max_steps
        ):
            # Check timeout
            elapsed = time.time() - start_time
            if elapsed >= timeout:
                self.context.print_info(f"Timeout reached after {elapsed:.1f}s")
                break

            # Prune states if too many - but maintain IOCTL diversity
            if len(simgr.active) > max_states:
                simgr.active = self._smart_state_pruning(simgr.active, max_states)

            try:
                simgr.step(num_inst=1)
                step_count += 1

                # Track unique addresses for metrics
                for state in simgr.active:
                    for addr in state.history.bbl_addrs:
                        self.context.unique_addresses.add(addr)

                if step_count % 1000 == 0:  # Reduced from 10000 for more frequent updates
                    self.context.print_debug(
                        f"Step {step_count}, elapsed: {elapsed:.1f}s, "
                        f"active: {len(simgr.active)}, deferred: {len(simgr.deferred)}"
                    )

            except Exception as e:
                # This specific error happens in angr when it tries to create a block at an invalid address
                # It's non-fatal and angr recovers from it
                if "unsupported operand type(s) for -: 'NoneType' and 'bool'" not in str(e):
                    self.context.print_error(f"Error during step: {e}")
                else:
                    self.context.print_debug(f"Known angr issue during step (non-fatal): {e}")
                simgr.move(from_stash="active", to_stash="_Drop")

        # Report final status
        if self._explosion_detector.state_exploded_bool:
            self.context.print_error("State explosion detected")

        if simgr.errored:
            for s in simgr.errored:
                self.context.print_error(f"Errored state: {repr(s)}")

        elapsed = time.time() - start_time
        self.context.print_info(
            f"Hunting complete: {step_count} steps in {elapsed:.1f}s, "
            f"found {len(self.context.vulnerabilities)} vulnerabilities"
        )

    def _smart_state_pruning(self, states: list[SimState], max_states: int) -> list[SimState]:
        """Prune states while maintaining diversity of IOCTL codes.

        Args:
            states: List of active states
            max_states: Maximum number of states to keep

        Returns:
            Pruned list of states maintaining IOCTL diversity
        """
        if not self.context.io_control_code:
            # No IOCTL tracking - fall back to simple pruning
            return sorted(states, key=lambda s: len(s.history.bbl_addrs))[:max_states]

        # Group states by their IoControlCode constraints
        ioctl_groups = {}
        unconstrained_states = []

        for state in states:
            try:
                # Check if IoControlCode is concrete
                if state.solver.symbolic(self.context.io_control_code):
                    # Still symbolic - group by possible values
                    possible_values = state.solver.eval_upto(self.context.io_control_code, 10)
                    if len(possible_values) == 1:
                        # Single value possible
                        ioctl_key = possible_values[0]
                    elif len(possible_values) < 10:
                        # Multiple specific values possible
                        ioctl_key = tuple(sorted(possible_values))
                    else:
                        # Too many possibilities - treat as unconstrained
                        unconstrained_states.append(state)
                        continue
                else:
                    # Concrete value
                    ioctl_key = state.solver.eval(self.context.io_control_code)

                if ioctl_key not in ioctl_groups:
                    ioctl_groups[ioctl_key] = []
                ioctl_groups[ioctl_key].append(state)

            except Exception:
                # If we can't evaluate, treat as unconstrained
                unconstrained_states.append(state)

        # Select states to keep
        selected = []

        # First priority: Keep at least one state per IOCTL value/group
        for ioctl_key, group_states in ioctl_groups.items():
            # Sort by history length (prefer shorter)
            group_states.sort(key=lambda s: len(s.history.bbl_addrs))

            # Always keep at least one state per IOCTL
            selected.append(group_states[0])

            # If we have budget, keep more from this group
            if len(selected) < max_states:
                states_per_group = max(1, (max_states - len(ioctl_groups)) // len(ioctl_groups))
                selected.extend(group_states[1:states_per_group])

        # Add unconstrained states if we have room
        if len(selected) < max_states:
            unconstrained_states.sort(key=lambda s: len(s.history.bbl_addrs))
            selected.extend(unconstrained_states[: max_states - len(selected)])

        # Final trim if still over limit
        if len(selected) > max_states:
            # Prioritize states with unique IOCTL values
            selected.sort(
                key=lambda s: (
                    # First priority: concrete IOCTL we haven't seen
                    0 if hasattr(s, "__ioctl_priority") else 1,
                    # Second priority: shorter history
                    len(s.history.bbl_addrs),
                )
            )
            selected = selected[:max_states]

        self.context.print_debug(
            f"State pruning: {len(states)} -> {len(selected)} states, {len(ioctl_groups)} IOCTL groups preserved"
        )

        return selected

    def _probe_known_ioctls(self, base_state: SimState, handler_addr: int) -> None:
        """Explicitly test known IOCTL values to ensure discovery.

        This helps find IOCTLs that might be pruned during symbolic execution.

        Args:
            base_state: Base state to test from
            handler_addr: IOCTL handler address
        """
        # Only test the specific IOCTLs we know should exist
        # Don't do broad exploration here - that's for the main symbolic execution
        test_ioctls = [
            0x12C800,  # The one we were missing!
            0x12C804,
            0x12C80C,
            0x12C810,
            0x12C814,
            0x12C8C0,
            0x12C8C4,
        ]

        self.context.print_info(f"Probing {len(test_ioctls)} potential IOCTL values...")

        for ioctl_val in test_ioctls:
            try:
                # Create a test state with this IOCTL (with resilience options)
                test_state = self.context.project.factory.call_state(
                    handler_addr,
                    claripy.BVV(base_state.globals.get("device_object_addr", 0), base_state.arch.bits),
                    self.context.irp_addr,
                    cc=self.context.calling_convention,
                    base_state=base_state,
                    add_options=angr.options.resilience,
                )

                # Set up minimal IRP structure
                io_control_code_sym = claripy.BVS("IoControlCode_test", 32)
                test_state.solver.add(io_control_code_sym == ioctl_val)

                # Just check if the constraint is satisfiable
                # Don't actually execute - let the main exploration handle that
                if test_state.satisfiable():
                    hex_ioctl = hex(ioctl_val)
                    if hex_ioctl not in self.context.ioctl_codes:
                        # Mark this as a candidate - will be confirmed during exploration
                        self.context.print_debug(f"IOCTL {hex_ioctl} is satisfiable - will explore")
                        # Don't add to ioctl_codes yet - let the main exploration confirm it

            except Exception:
                # Silently continue - not all IOCTLs will work
                pass

        self.context.print_info(f"Probe complete. Found {len(self.context.ioctl_codes)} IOCTLs so far.")

    def _hunt_specific_ioctl(
        self, driver_base_state: SimState, ioctl_handler_addr: int, ioctl_code: str
    ) -> list[dict[str, Any]]:
        """Hunt vulnerabilities for a specific IOCTL code.

        This targeted approach is useful for finding IOCTLs that get pruned
        during general exploration.

        Args:
            driver_base_state: Base state from IOCTL handler discovery
            ioctl_handler_addr: Address of the IOCTL handler
            ioctl_code: Specific IOCTL code to test (hex string)

        Returns:
            List of discovered vulnerabilities
        """
        self.context.print_info(f"Targeted hunting for IOCTL {ioctl_code}")

        # Save current vulnerabilities to append to them
        saved_vulns = self.context.vulnerabilities.copy()

        # Create a constrained state for this specific IOCTL
        # Set up device object address
        globals_dict = cast(dict[str, Any], driver_base_state.globals)
        if "device_object_addr" in globals_dict:
            device_object_addr = claripy.BVV(globals_dict["device_object_addr"], driver_base_state.arch.bits)
        else:
            device_object_addr = claripy.BVS("device_object_addr", driver_base_state.arch.bits)
            globals_dict["open_section_handles"] = ()
            globals_dict["tainted_unicode_strings"] = ()

        # Initialize tainted tracking
        globals_dict["tainted_ProbeForRead"] = ()
        globals_dict["tainted_ProbeForWrite"] = ()
        globals_dict["tainted_MmIsAddressValid"] = ()
        globals_dict["tainted_eprocess"] = ()
        globals_dict["tainted_handles"] = ()

        # Create state at IOCTL handler entry point with resilience options
        # to handle unsupported VEX operations like Iop_32Uto64
        import angr

        state = self.context.project.factory.call_state(
            ioctl_handler_addr,
            device_object_addr,
            self.context.irp_addr,
            cc=self.context.calling_convention,
            base_state=driver_base_state,
            add_options=angr.options.resilience,
        )

        # Store context in state globals so hooks can access it
        cast(dict[str, Any], state.globals)["analysis_context"] = self.context

        # Set up CR8 register
        cr8 = claripy.BVS("cr8", state.arch.bits)
        state.registers.store("cr8", cr8)

        # Set up IRP structure
        irp = claripy.BVS("irp_buf", 8 * 0x200)
        self.context.system_buffer = claripy.BVS("SystemBuffer", state.arch.bits)
        self.context.type3_input_buffer = claripy.BVS("Type3InputBuffer", state.arch.bits)
        self.context.user_buffer = claripy.BVS("UserBuffer", state.arch.bits)

        # Clear existing breakpoints and set up vulnerability detection breakpoints
        self._setup_breakpoints(state)

        # Store IRP in memory
        state.memory.store(self.context.irp_addr, irp)

        # Set up symbolic IOCTL parameters
        minor_func = claripy.BVS("MinorFunction", 8)
        self.context.output_buffer_length = claripy.BVS("OutputBufferLength", 32)
        self.context.input_buffer_length = claripy.BVS("InputBufferLength", 32)

        # IMPORTANT: Use a concrete value for IoControlCode
        ioctl_val = int(ioctl_code, 16)
        self.context.io_control_code = claripy.BVV(ioctl_val, 32)

        # Set up IRP structure fields
        self._setup_irp_structure(state, minor_func)

        # Override with concrete IOCTL value
        params = state.mem[self.context.irsp_addr].IO_STACK_LOCATION.Parameters
        params.DeviceIoControl.IoControlCode.val = ioctl_val

        # Create simulation manager with higher limits for targeted exploration
        simgr = self.context.project.factory.simgr(state, save_unconstrained=True)
        simgr.populate("found", [])
        simgr.use_technique(angr.exploration_techniques.DFS())

        # Use more aggressive exploration for targeted hunting
        if self.context.config.bound:
            simgr.use_technique(
                angr.exploration_techniques.LoopSeer(
                    cfg=self.context.cfg,
                    functions=None,
                    bound=self.context.config.bound * 2,  # Double the bound for targeted
                )
            )

        # Set up state explosion detection with higher threshold
        ed = ExplosionDetector(self.context, threshold=20000)
        simgr.use_technique(ed)
        self._explosion_detector = ed

        # Store simulation manager in context
        self.context.simulation_manager = simgr

        # Run targeted symbolic execution
        start_time = time.time()
        step_count = 0
        max_steps = 100000  # Still need thorough exploration for single IOCTL
        timeout = 60  # Reasonable timeout for single IOCTL
        max_states = 150  # Keep reasonable number of states

        while (
            (len(simgr.active) > 0 or len(simgr.deferred) > 0) and not ed.state_exploded_bool and step_count < max_steps
        ):
            # Check timeout
            elapsed = time.time() - start_time
            if elapsed >= timeout:
                self.context.print_info(f"Targeted hunt timeout after {elapsed:.1f}s")
                break

            # Simple pruning for targeted exploration
            if len(simgr.active) > max_states:
                simgr.active = sorted(simgr.active, key=lambda s: len(s.history.bbl_addrs))[:max_states]

            try:
                simgr.step(num_inst=1)
                step_count += 1

                if step_count % 1000 == 0:
                    self.context.print_debug(
                        f"Targeted step {step_count}, elapsed: {elapsed:.1f}s, active: {len(simgr.active)}"
                    )

            except Exception as e:
                # This specific error happens in angr when it tries to create a block at an invalid address
                # It's non-fatal and angr recovers from it
                if "unsupported operand type(s) for -: 'NoneType' and 'bool'" not in str(e):
                    self.context.print_error(f"Error during targeted step: {e}")
                else:
                    self.context.print_debug(f"Known angr issue during targeted step (non-fatal): {e}")
                simgr.move(from_stash="active", to_stash="_Drop")

        # Check if we found the IOCTL
        if ioctl_code not in self.context.ioctl_codes:
            # The IOCTL was reachable, add it
            self.context.ioctl_codes.append(ioctl_code)
            self.context.print_info(f"Targeted hunt discovered IOCTL {ioctl_code}")

        elapsed = time.time() - start_time
        self.context.print_info(
            f"Targeted hunt complete: {step_count} steps in {elapsed:.1f}s, "
            f"found {len(self.context.vulnerabilities) - len(saved_vulns)} new vulnerabilities"
        )

        # Merge saved vulnerabilities back - don't lose previous findings
        if saved_vulns:
            for vuln in saved_vulns:
                if vuln not in self.context.vulnerabilities:
                    self.context.vulnerabilities.append(vuln)

        return self.context.vulnerabilities


def hunt_vulnerabilities(
    driver_path: Path | str,
    ioctl_handler: IOCTLHandler | int,
    ioctl_code: str | None = None,
    timeout: int = 120,
) -> list[Vulnerability]:
    """High-level function to hunt vulnerabilities in a driver.

    Args:
        driver_path: Path to the driver file
        ioctl_handler: IOCTL handler information
        ioctl_code: Specific IOCTL code to test
        timeout: Maximum time for analysis

    Returns:
        List of discovered vulnerabilities
    """
    from ..core.analysis_context import AnalysisConfig, AnalysisContext

    # Create context
    config = AnalysisConfig(timeout=timeout)
    context = AnalysisContext.create_for_driver(driver_path, config)

    # Create hunter
    hunter = VulnerabilityHunter(context)

    # Create base state
    import angr

    base_state = context.project.factory.blank_state(add_options=angr.options.resilience)

    # Hunt for vulnerabilities
    handler_addr = int(ioctl_handler.address, 16) if isinstance(ioctl_handler, IOCTLHandler) else ioctl_handler
    vulns = hunter.hunt(base_state, handler_addr, ioctl_code)

    # Convert to Vulnerability models
    return [Vulnerability.from_legacy_format(v) for v in vulns]
