"""Vulnerability data models for IOCTLance."""

from datetime import datetime
from typing import Any

from pydantic import BaseModel, Field, field_validator

from .raw_state import RawVulnerabilityData


class VulnerabilityEvaluation(BaseModel):
    """Evaluation parameters that triggered the vulnerability."""

    IoControlCode: str = Field(..., description="IOCTL code that triggers vulnerability")
    SystemBuffer: str = Field(..., description="System buffer address")
    Type3InputBuffer: str = Field(..., description="Type3 input buffer address")
    UserBuffer: str = Field(..., description="User buffer address")
    InputBufferLength: str = Field(..., description="Input buffer length")
    OutputBufferLength: str = Field(..., description="Output buffer length")

    @field_validator("IoControlCode")
    @classmethod
    def validate_ioctl_code(cls, v: str) -> str:
        """Validate IOCTL code format."""
        if not v.startswith("0x"):
            raise ValueError("IOCTL code must be in hexadecimal format (0x...)")
        return v


class Vulnerability(BaseModel):
    """Represents a discovered vulnerability."""

    title: str = Field(..., description="Vulnerability type and description")
    description: str = Field(..., description="Detailed vulnerability description")
    state: str = Field(..., description="State address where vulnerability was found")
    eval: VulnerabilityEvaluation = Field(..., description="Evaluation parameters")
    parameters: dict[str, Any] = Field(default_factory=dict, description="Additional parameters")
    others: dict[str, Any] = Field(default_factory=dict, description="Other relevant information")
    discovered_at: datetime = Field(default_factory=datetime.now, description="Discovery timestamp")
    raw_data: RawVulnerabilityData | None = Field(None, description="Complete raw state data")

    @field_validator("state")
    @classmethod
    def validate_state(cls, v: str) -> str:
        """Validate state format."""
        if not v.startswith("<SimState @"):
            raise ValueError("State must be in format '<SimState @ 0x...>'")
        return v

    @property
    def severity(self) -> str:
        """Determine vulnerability severity based on type."""
        title_lower = self.title.lower()
        if "arbitrary" in title_lower or "code execution" in title_lower:
            return "CRITICAL"
        elif "overflow" in title_lower or "null pointer" in title_lower:
            return "HIGH"
        elif "race condition" in title_lower:
            return "MEDIUM"
        else:
            return "LOW"

    @property
    def vulnerability_type(self) -> str:
        """Extract vulnerability type from title."""
        title_lower = self.title.lower()
        if "null pointer" in title_lower:
            return "NULL_POINTER_DEREFERENCE"
        elif "buffer overflow" in title_lower:
            return "BUFFER_OVERFLOW"
        elif "arbitrary read" in title_lower:
            return "ARBITRARY_READ"
        elif "arbitrary write" in title_lower:
            return "ARBITRARY_WRITE"
        elif "race condition" in title_lower:
            return "RACE_CONDITION"
        else:
            return "UNKNOWN"
    
    @classmethod
    def from_legacy_format(cls, data: dict[str, Any]) -> "Vulnerability":
        """Create Vulnerability from legacy format dictionary.
        
        Args:
            data: Legacy vulnerability dictionary
            
        Returns:
            Vulnerability instance
        """
        # Handle eval field - it might be a dict already or need conversion
        eval_data = data.get("eval", {})
        if not isinstance(eval_data, dict):
            eval_data = {}
        
        # Ensure all required fields for VulnerabilityEvaluation
        eval_formatted = {
            "IoControlCode": eval_data.get("IoControlCode", "0x0"),
            "SystemBuffer": eval_data.get("SystemBuffer", "0x0"),
            "Type3InputBuffer": eval_data.get("Type3InputBuffer", "<BV64 Type3InputBuffer>"),
            "UserBuffer": eval_data.get("UserBuffer", "<BV64 UserBuffer>"),
            "InputBufferLength": eval_data.get("InputBufferLength", "<BV32 InputBufferLength>"),
            "OutputBufferLength": eval_data.get("OutputBufferLength", "<BV32 OutputBufferLength>"),
        }
        
        return cls(
            title=data.get("title", "Unknown vulnerability"),
            description=data.get("description", "No description"),
            state=data.get("state", "<SimState @ 0x0>"),
            eval=VulnerabilityEvaluation(**eval_formatted),
            parameters=data.get("parameters", {}),
            others=data.get("others", {}),
            discovered_at=datetime.fromisoformat(data["discovered_at"]) if "discovered_at" in data and isinstance(data["discovered_at"], str) else datetime.now(),
        )
